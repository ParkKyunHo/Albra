"""
Event Classes for Event-Driven Backtesting

This module defines the core event types used in the backtesting system.
All events inherit from the base Event class and are processed by the
event queue in the main backtesting loop.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any, Literal
from decimal import Decimal


class Event(ABC):
    """Base class for all events in the backtesting system."""
    
    @abstractmethod
    def __repr__(self) -> str:
        """String representation of the event."""
        pass


@dataclass
class MarketEvent(Event):
    """
    Market data event containing OHLCV data for a specific timestamp.
    
    Attributes:
        timestamp: The timestamp of the market data
        symbol: The trading symbol (e.g., 'BTC/USDT')
        open: Open price
        high: High price
        low: Low price
        close: Close price
        volume: Trading volume
        indicators: Pre-calculated indicators for this timestamp
    """
    timestamp: datetime
    symbol: str
    open: float
    high: float
    low: float
    close: float
    volume: float
    indicators: Dict[str, float] = field(default_factory=dict)
    
    def __repr__(self) -> str:
        return f"MarketEvent({self.symbol}, {self.timestamp}, close={self.close})"


@dataclass
class SignalEvent(Event):
    """
    Trading signal generated by a strategy.
    
    Attributes:
        timestamp: When the signal was generated
        symbol: The trading symbol
        signal_type: BUY, SELL, or HOLD
        strength: Signal strength (0-1, where 1 is strongest)
        strategy_name: Name of the strategy that generated this signal
        metadata: Additional signal information
    """
    timestamp: datetime
    symbol: str
    signal_type: Literal['BUY', 'SELL', 'HOLD']
    strength: float
    strategy_name: str
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate signal strength is between 0 and 1."""
        if not 0 <= self.strength <= 1:
            raise ValueError(f"Signal strength must be between 0 and 1, got {self.strength}")
    
    def __repr__(self) -> str:
        return f"SignalEvent({self.signal_type}, {self.symbol}, strength={self.strength:.2f})"


@dataclass
class OrderEvent(Event):
    """
    Order request to be sent to the broker.
    
    Attributes:
        timestamp: When the order was created
        symbol: The trading symbol
        order_type: MARKET or LIMIT
        direction: BUY or SELL
        quantity: Amount to trade (in base currency)
        price: Limit price (None for market orders)
        stop_loss: Stop loss price
        take_profit: Take profit price
        metadata: Additional order information
    """
    timestamp: datetime
    symbol: str
    order_type: Literal['MARKET', 'LIMIT']
    direction: Literal['BUY', 'SELL']
    quantity: float
    price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate order parameters."""
        if self.quantity <= 0:
            raise ValueError(f"Order quantity must be positive, got {self.quantity}")
        if self.order_type == 'LIMIT' and self.price is None:
            raise ValueError("Limit orders must specify a price")
    
    def __repr__(self) -> str:
        return f"OrderEvent({self.direction} {self.quantity} {self.symbol} @ {self.price or 'MARKET'})"


@dataclass
class FillEvent(Event):
    """
    Order fill confirmation from the broker.
    
    Attributes:
        timestamp: When the order was filled
        symbol: The trading symbol
        direction: BUY or SELL
        quantity: Actual filled quantity
        price: Actual fill price
        commission: Trading commission paid
        slippage: Slippage cost
        order_id: Unique order identifier
        metadata: Additional fill information
    """
    timestamp: datetime
    symbol: str
    direction: Literal['BUY', 'SELL']
    quantity: float
    price: float
    commission: float
    slippage: float
    order_id: str
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def total_cost(self) -> float:
        """Calculate total cost including commission and slippage."""
        base_cost = self.quantity * self.price
        return base_cost + self.commission + (base_cost * self.slippage)
    
    def __repr__(self) -> str:
        return (f"FillEvent({self.direction} {self.quantity} {self.symbol} "
                f"@ {self.price}, cost={self.total_cost:.2f})")


@dataclass
class RiskEvent(Event):
    """
    Risk management event for position adjustments or warnings.
    
    Attributes:
        timestamp: When the risk event was triggered
        risk_type: Type of risk event
        severity: LOW, MEDIUM, HIGH, CRITICAL
        message: Human-readable risk message
        action: Recommended action
        metadata: Additional risk information
    """
    timestamp: datetime
    risk_type: Literal['DRAWDOWN', 'POSITION_SIZE', 'LEVERAGE', 'DAILY_LOSS', 'MARGIN_CALL']
    severity: Literal['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']
    message: str
    action: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __repr__(self) -> str:
        return f"RiskEvent({self.risk_type}, {self.severity}: {self.message})"